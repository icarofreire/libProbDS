/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example;

import java.lang.Math;


/**
 * Count-Min Sketch: A Count-Min sketch is a probabilistic data structure used to count the
 * frequency of elements in a data stream with a small probability of overestimation.
 * 
 * Pros: Efficient estimation of item frequencies, low memory footprint.
 * Cons: May have slight overestimation of frequencies, not suitable for precise frequency counting.
 * 
 * Use Cases:
 * 
 * Network traffic analysis: Count-Min sketches can be used to track the frequency of IP addresses
 * or other network entities in a data stream, helping to identify heavy hitters or potential DDoS attacks.
 * Text analysis: Count-Min sketches can be used to estimate the frequency of words or phrases in
 * a large text corpus, enabling applications like trending topic detection or word cloud generation.
 * Recommendation systems: Count-Min sketches can be used to track user-item interactions in a
 * recommendation system, allowing for efficient computation of item popularity or user similarity.
 */
public class CountMinSketch {

    private int width;
    private int depth;
    private int[][] storage;
    private final int neg = -1;

    CountMinSketch(int width, int depth) {
        this.width = width;
        this.depth = depth;
        int tam = Math.max(width, depth);
        this.storage = new int[tam][tam];

        for(int i = 0; i < width; i++){
            for(int j = 0; j < depth; j++){
                this.storage[i][j] = 0;
            }
        }
    }

    // Simple hash function
    public int hash(int value, int seed) {
        return (value * seed) % this.width;
    }

    // Increment the count of an element
    public void add(int value) {
        for (int i = 0; i < this.depth; i++) {
            final int j = this.hash(value, i + 1);
            // this.storage[i] ??= {};
            // this.storage[i][j] ? this.storage[i][j]++ : (this.storage[i][j] = 1);
            if(this.storage[i][j] != 0){
                this.storage[i][j]++;
            }else{
                this.storage[i][j] = 1;
            }
        }
    }

    // Estimate the count of an element
    public int count(int value) {
        int min = Integer.MAX_VALUE;
        for (int i = 0; i < this.depth; i++) {
            // min = Math.min(min, this.storage[i]?.[this.hash(value, i + 1)] || 0);
            min = Math.min(min, this.storage[i][this.hash(value, i + 1)]/* || 0*/);
        }
        return min;
    }

    public static void teste() {
        // Usage example
        var countMinSketch = new CountMinSketch(100, 5);
        countMinSketch.add(10);
        System.out.println(countMinSketch.count(10)); // 1 (or higher if there's a collision)
        System.out.println(countMinSketch.count(20)); // 0

        Teste.very(countMinSketch.count(10) == 1 || countMinSketch.count(10) > 1, true);
        Teste.very(countMinSketch.count(20) == 0, true);
    }
}
