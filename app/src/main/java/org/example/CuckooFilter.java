/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example;

import java.lang.Math;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.nio.charset.StandardCharsets;
import java.lang.StringBuilder;
import java.math.BigInteger;


record Fingerprint(
    int fingerprint,
    int index1,
    int index2
) {
}


/**
 * Cuckoo Filter: Cuckoo Filters are probabilistic data structures that provide an efficient solution
 * for approximate set membership queries. They are similar to Bloom Filters but offer additional
 * features such as deletion support and a higher load factor and are particularly useful in scenarios
 * where space efficiency, membership testing, and deletions are essential.
 * 
 * Pros: Efficient membership testing, compact representation.
 * Cons: Limited support for deletion, additional memory for fingerprint storage.
 * 
 * Use Cases:
 * 
 * Network routers and switches: Cuckoo Filters are used to efficiently store and query large sets of network
 * flow information, such as source/destination IP addresses, port numbers, or protocols. They provide a compact
 * data structure for fast lookup and filtering of network flows.
 * Web caches and content delivery networks (CDNs): Cuckoo Filters are used to store the URLs or content
 * signatures of web pages or files in a cache or CDN. They help quickly determine if a requested resource is
 * already cached, avoiding unnecessary retrieval from the origin server.
 * Anti-malware and spam filters: Cuckoo Filters are utilized in malware detection systems and email spam filters.
 * They allow for fast matching and identification of known malicious URLs, file hashes, or email signatures,
 * enabling efficient detection and prevention of malicious content.
 */
class CuckooFilter {

    private int capacity;
    private int bucketSize;
    private int fingerprintSize;
    private int[][] buckets;
    private final int neg = -1;

    CuckooFilter(int capacity, int bucketSize, int fingerprintSize) {
        this.capacity = capacity;
        this.bucketSize = bucketSize;
        this.fingerprintSize = fingerprintSize;
        this.buckets = new int[capacity][capacity];

        // Initialize buckets
        for (int i = 0; i < capacity; i++) {
            for (int j = 0; j < capacity; j++) {
                this.buckets[i][j] = this.neg;
            }
        }
    }

    // Hash function to generate a hash value for the input
    public int hash(String value) {
        return hashStringToBigIntSHA3_256(value).abs().intValue();
    }
    
    public BigInteger hashStringToBigIntSHA3_256(String inputString) {
        try {
            // Get a SHA3-256 MessageDigest instance
            MessageDigest digest = MessageDigest.getInstance("SHA3-256");

            // Hash the input string bytes
            byte[] hashBytes = digest.digest(inputString.getBytes(StandardCharsets.UTF_8));

            // Convert the byte array to a BigInteger
            // The '1' in BigInteger(1, hashBytes) ensures a positive BigInteger value
            return new BigInteger(1, hashBytes);

        } catch (NoSuchAlgorithmException e) {
            // Handle the case where SHA3-256 algorithm is not available
            e.printStackTrace();
            return null; // Or throw a custom exception
        }
    }

    // Compute the fingerprint of an element using a hash function
    public int computeFingerprint(String element) {
        // Convert element to string
        // const str = String(element);

        // Use a hash function to compute the fingerprint
        // Here, we simply take the lower 'fingerprintSize' bits of the hash value
        final int hash = this.hash(element);
        final int fingerprint = hash & ((1 << this.fingerprintSize) - 1);

        return fingerprint;
    }

    // Get the fingerprint and index of the bucket for an element
    public Fingerprint getFingerprintAndIndex(String element) {
        final int fingerprint = this.computeFingerprint(element);
        final int index1 = this.hash(element) % this.capacity;
        final int index2 = (index1 ^ this.hash(String.valueOf(fingerprint))) % this.capacity;

        return new Fingerprint(fingerprint, index1, index2);
    }

    // Insert an element into the Cuckoo Filter
    public boolean insert(String element) {
        //   const { fingerprint, index1, index2 } = this.getFingerprintAndIndex(element);
        Fingerprint finger = this.getFingerprintAndIndex(element);

        // Try to insert in the first bucket
        for (int i = 0; i < this.bucketSize; i++) {
            // if(finger.index1() < this.capacity && i < this.capacity){
            if (this.buckets[finger.index1()][i] == this.neg) {
                this.buckets[finger.index1()][i] = finger.fingerprint();
                return true; // Insertion successful
            }
            // }
        }

        // Try to insert in the second bucket
        for (int i = 0; i < this.bucketSize; i++) {
            // // if(finger.index2() < this.capacity && i < this.capacity){
            if (this.buckets[finger.index2()][i] == this.neg) {
                this.buckets[finger.index2()][i] = finger.fingerprint();
                return true; // Insertion successful
            }
            // }
        }

        // Perform eviction if both buckets are full
        var evictionIndex = Math.random() < 0.5 ? finger.index1() : finger.index2();
        var evictedFingerprint =
        this.buckets[evictionIndex][(int)Math.floor(Math.random() * this.bucketSize)];
        this.buckets[evictionIndex][(int)Math.floor(Math.random() * this.bucketSize)] =
        finger.fingerprint();

        // Retry inserting the evicted element recursively
        return this.insert(String.valueOf(evictedFingerprint));
    }

    // Check if an element may be present in the Cuckoo Filter
    public boolean contains(String element) {
        //   const { fingerprint, index1, index2 } = this.getFingerprintAndIndex(element);
        Fingerprint finger = this.getFingerprintAndIndex(element);

        // Check in the first bucket
        for (int i = 0; i < this.bucketSize; i++) {
            if (this.buckets[finger.index1()][i] == finger.fingerprint()) {
                return true; // Element may be present
            }
        }

        // Check in the second bucket
        for (int i = 0; i < this.bucketSize; i++) {
            if (this.buckets[finger.index2()][i] == finger.fingerprint()) {
                return true; // Element may be present
            }
        }

        return false; // Element is definitely not present
    }

    public static void teste() {
        // Usage example:
        var cuckooFilter = new CuckooFilter(1000, 4, 8); // Capacity: 1000, Bucket size: 4, Fingerprint size: 8

        cuckooFilter.insert("apple");
        cuckooFilter.insert("banana");
        cuckooFilter.insert("cherry");

        System.out.println(cuckooFilter.contains("apple")); // Output: true
        System.out.println(cuckooFilter.contains("grape")); // Output: false
    }
}
