/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example;

import java.lang.Math;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.nio.charset.StandardCharsets;
import java.lang.StringBuilder;
import java.math.BigInteger;
import java.util.HashMap;
import java.util.Arrays;
import java.util.OptionalInt;


/**
 * HyperLogLog: HyperLogLog is a probabilistic data structure used for cardinality estimation.
 * It provides an estimate number of distinct elements in a large dataset with a certain error rate.
 * 
 * Pros: High accuracy in estimating cardinality, minimal memory requirement.
 * Cons: Cannot retrieve individual items, limited to cardinality estimation.
 * 
 * Use Cases:
 * 
 * Analytics: HyperLogLog can be used to estimate the number of unique visitors to a website or the number
 * of distinct elements in a data stream, providing valuable insights for analytics and reporting.
 * Database systems: HyperLogLog can be used to estimate the cardinality of large datasets, helping to
 * optimize query planning and execution in database systems.
 * Data mining: HyperLogLog can be used to estimate the number of distinct items in large datasets,
 * enabling efficient processing of tasks like frequent item set-mining or clustering.
 */
public class HyperLogLog {

    private int precision;
    private int[] registers;

    private HashMap<Integer, Double> alphaMap = new HashMap<>();

    HyperLogLog(int precision) {
        this.precision = precision; // Number of bits used for counting leading zeros
        this.registers = new int[(int)Math.pow(2, precision)]; // Array of registers
    }

    // Hash function to generate a hash value for the input
    // public int hash(String value, boolean abs) {
    //     int bign = hashStringToBigIntSHA3_256(value).abs().intValue();
    //     return (abs) ? (Math.abs(bign)) : (bign);
    // }
    
    // public BigInteger hashStringToBigIntSHA3_256(String inputString) {
    //     try {
    //         // Get a SHA3-256 MessageDigest instance
    //         MessageDigest digest = MessageDigest.getInstance("SHA3-256"); //SHA-256

    //         // Hash the input string bytes
    //         byte[] hashBytes = digest.digest(inputString.getBytes(StandardCharsets.UTF_8));

    //         // Convert the byte array to a BigInteger
    //         // The '1' in BigInteger(1, hashBytes) ensures a positive BigInteger value
    //         return new BigInteger(1, hashBytes);

    //     } catch (NoSuchAlgorithmException e) {
    //         // Handle the case where SHA3-256 algorithm is not available
    //         e.printStackTrace();
    //         return null; // Or throw a custom exception
    //     }
    // }

    public void add(String element) {
        final int hash = this.hash(element); // Compute the hash value of the element
        final int index = this.getIndex(hash); // Compute the index in the registers array
        final int rank = this.getRank(hash, this.precision); // Compute the rank (number of leading zeros) of the hash value
        if (rank > this.registers[index]) {
            // If the rank is greater than the current register value, update the register
            this.registers[index] = rank;
        }
    }

    public double count() {
        final double alpha = this.getAlpha(this.precision); // Get the alpha correction factor based on the precision
        final OptionalInt optsum = Arrays.stream(this.registers).reduce((accumulator, register) -> {
            // Compute the sum of 1/(2^register) for all registers
            return accumulator + (int)Math.pow(1 / 2, register);
        });
        int sum = optsum.orElse(0);
        final double estimate = alpha * (1 / sum); // Compute the estimated cardinality based on the alpha factor and sum

        // Apply small range corrections
        if (estimate <= 2.5 * this.registers.length) {
            //    const zeroCount = java.util.Arrays.stream(this.registers).filter(
            //     (register) => register === 0
            //    ).length;

                int[] zeros = Arrays.stream(this.registers)
                            .filter(register -> register == 0)
                            .toArray();
                final int zeroCount = zeros.length;

            // If there are non-zero registers, apply linear counting correction
            if (zeroCount != 0) {
                return Math.round(
                    this.linearCounting(this.registers.length, zeroCount)
                );
            }
        }

        // Apply large range corrections
        if (estimate > (1 / 30) * Math.pow(2, 32)) {
            return Math.round(-(Math.pow(2, 32)) * Math.log(1 - estimate / Math.pow(2, 32)));
        }

        return Math.round(estimate); // Return the rounded estimated cardinality
    }

    public int hash(String element) {
        // Implement a suitable hash function (e.g., murmurhash3, xxHash)
        // Convert the element to a unique hash value
        // For simplicity, we use a simple string hash
        int hash = 0;
        for (int i = 0; i < element.length(); i++) {
            hash = (hash << 5) - hash + element.charAt(i);
            hash |= 0;
        }
        return hash;
    }

    public int getIndex(int hash) {
        // Compute the index in the registers array based on the hash value
        return hash >>> (32 - this.precision);
    }

    public int getRank(int hash, int bitCount) {
        // Compute the rank (number of leading zeros) of the hash value, considering the bitCount
        final int mask = (1 << bitCount) - 1;
        return this.countLeadingZeros(hash & mask, bitCount) + 1;
    }

    public int countLeadingZeros(int num, int bitCount) {
        // Count the number of leading zeros in a number
        if (num == 0) return bitCount;
        int count = 0;
        while ((num & 0x80000000) == 0) {
            num <<= 1;
            count++;
        }
        return count;
    }

    public double getAlpha(int bitCount) {
        // Get the alpha correction factor based on the bitCount
        // const alphaMap = {
        // 4: 0.673,
        // 5: 0.697,
        // 6: 0.709,
        // 7: 0.715,
        // 8: 0.718,
        // 9: 0.72,
        // 10: 0.721,
        // };
        alphaMap.put(4, 0.673);
        alphaMap.put(5, 0.697);
        alphaMap.put(6, 0.709);
        alphaMap.put(7, 0.715);
        alphaMap.put(8, 0.718);
        alphaMap.put(9, 0.72);
        alphaMap.put(10, 0.721);

        if(alphaMap.containsKey(bitCount)){
            return alphaMap.get(bitCount);
        }
        return (0.7213 / (1 + 1.079 / (1 << bitCount)));
        // return alphaMap.get(bitCount) || 0.7213 / (1 + 1.079 / (1 << bitCount));
    }

    public double linearCounting(int registerCount, int zeroCount) {
        // Apply linear counting correction to estimate the cardinality
        return registerCount * Math.log(registerCount / zeroCount);
    }

    public static void teste() {
        // Create a new HyperLogLog with a precision of 10 bits
        var hll = new HyperLogLog(10);

        // Add elements to the HyperLogLog
        hll.add("apple");
        hll.add("orange");
        hll.add("banana");
        hll.add("apple");

        // Estimate the cardinality
        System.out.println("Estimated Cardinality:" + hll.count()); // Output: Estimated Cardinality: 3
        Teste.very(hll.count() != 3, false);
    }
}
