/*
 * This source file was generated by the Gradle 'init' task
 */
package org.lib;

import java.lang.Math;

class SkipListNode {

    public SkipListNode[] forward;
    public int value;

    public SkipListNode(int value, int level) {
        this.value = value; // Node value
        this.forward = new SkipListNode[level + 1]; // Array of references to next nodes
    }
}

/**
 * https://www.baeldung.com/java-skiplist
 * https://medium.com/@asishpanda444/skip-lists-9e4cd1ee6444
 */

/**
 * Skip List: A Skip List is a probabilistic data structure that allows for efficient searching,
 * insertion, and deletion operations in logarithmic time complexity.
 * It is designed as an alternative to balanced binary search trees,
 * providing a simpler implementation while maintaining similar performance guarantees.
 * 
 * Pros: Efficient insertion, deletion, and search operations, simple implementation.
 * Cons: Increased memory usage compared to other probabilistic data structures.
 * 
 * Use Cases:
 * 
 * In-memory databases: Skip Lists are commonly used as the underlying data structure in in-memory
 * databases to provide efficient indexing and searching capabilities. They allow for fast lookups, insertions,
 * and deletions, making them suitable for high-performance database systems.
 * Concurrent data structures: Skip Lists can be adapted to support concurrent operations by applying synchronization techniques.
 * They offer good concurrency control due to their inherent hierarchical structure, making them valuable for concurrent data
 * structures like concurrent sets, maps, and priority queues.
 * Range queries: Skip Lists efficiently support range queries, where you need to retrieve all elements within a specific range.
 * By leveraging the hierarchical nature of Skip Lists, you can efficiently identify and iterate over elements within a given range,
 * enabling efficient range-based operations in various applications such as database systems and search engines.
 */
public class SkipList {
 
    private SkipListNode head;
    private int maxLevel = 16; // Maximum level of the Skip List

    public SkipList() {
        this.head = new SkipListNode(0, this.maxLevel); // Head node
    }

    public int randomLevel() {
        int level = 0;
        while (new java.util.Random().nextDouble() < 0.5 && level < this.maxLevel + 1) {
            level++;
        }
        return level;
    }

    public void insert(int value) {
        final SkipListNode[] update = new SkipListNode[this.maxLevel + 1]; // Array to track update pointers
        SkipListNode currentNode = this.head;

        for (int i = this.maxLevel; i >= 0; i--) {
            while (currentNode.forward[i] != null && currentNode.forward[i].value < value) {
                    currentNode = currentNode.forward[i];
            }
            update[i] = currentNode;
        }

        currentNode = currentNode.forward[0];

        if (currentNode == null || currentNode.value != value) {
            final int newNodeLevel = this.randomLevel();
            // System.out.println("newNodeLevel:" + newNodeLevel);
            if (newNodeLevel > this.maxLevel) {
                for (int i = this.maxLevel + 1; i <= newNodeLevel; i++) {
                    update[i] = this.head;
                }
                this.maxLevel = newNodeLevel;
            }

            final SkipListNode newNode = new SkipListNode(value, newNodeLevel);
            for (int i = 0; i <= newNodeLevel; i++) {
                newNode.forward[i] = update[i].forward[i];
                update[i].forward[i] = newNode;
            }
        }
    }

    public boolean search(int value) {
        SkipListNode currentNode = this.head;

        for (int i = this.maxLevel; i >= 0; i--) {
            while (currentNode.forward[i] != null && currentNode.forward[i].value < value) {
                currentNode = currentNode.forward[i];
            }
        }
        currentNode = currentNode.forward[0];
        return currentNode != null && currentNode.value == value;
    }

    public void remove(int value) {
        final SkipListNode[] update = new SkipListNode[this.maxLevel + 1]; // Array to track update pointers
        SkipListNode currentNode = this.head;

        for (int i = this.maxLevel; i >= 0; i--) {
            while (currentNode.forward[i] != null && currentNode.forward[i].value < value) {
                currentNode = currentNode.forward[i];
            }
            update[i] = currentNode;
        }

        currentNode = currentNode.forward[0];

        if (currentNode != null && currentNode.value == value) {
            for (int i = 0; i <= this.maxLevel; i++) {
                if (update[i].forward[i] != currentNode) {
                break;
                }
                update[i].forward[i] = currentNode.forward[i];
            }

            while (this.maxLevel > 0 && this.head.forward[this.maxLevel] == null) {
                this.maxLevel--;
            }
        }
    }

    public static void teste(){
        // Create a new Skip List
        final SkipList skipList = new SkipList();

        int[] dataStream = {10, 20, 15, 5};

        // Insert values into the Skip List
        java.util.Arrays.stream(dataStream).forEach((element) -> skipList.insert(element));

        // Search for a value in the Skip List
        int search = 15;
        System.out.println("Search for " + search + ": " + skipList.search(search)); // Output: true

        // Remove a value from the Skip List
        search = 20;
        skipList.remove(search);

        // Search for the removed value
        System.out.println("Search for " + search + ": " + skipList.search(search)); // Output: false
    }
}
