/*
 * This source file was generated by the Gradle 'init' task
 */
package org.lib;

import java.lang.Math;

import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.nio.charset.StandardCharsets;
import java.lang.StringBuilder;
import java.math.BigInteger;

/**
 * Quotient Filter: A Quotient Filter is a probabilistic data structure similar to a Bloom Filter,
 * but with some advantages. It provides a space-efficient representation of a set of elements and
 * can efficiently test whether an element is a member of a set. The main advantage of a Quotient
 * Filter over a Bloom Filter is that it supports deletions and has better cache performance due to its locality of reference.
 * 
 * Pros: Fast membership testing, memory-efficient.
 * Cons: Limited support for deletion, possibility of false positives.
 * 
 * Use Cases:
 * 
 * Network Routing: Quotient Filters can be used in routers to store a large number of network routes efficiently.
 * They allow for fast routing table lookups by determining whether a given IP address belongs to a particular route.
 * Caching: Quotient Filters can be used in caching systems to quickly determine if a particular object or resource
 * is present in the cache. This helps in reducing expensive disk or database lookups by caching frequently accessed items.
 * Duplicate Detection: Quotient Filters can be used to identify duplicate elements in a large dataset.
 * By inserting elements into the filter, you can quickly check if an incoming element is a duplicate, enabling efficient deduplication processes.
 */
public class QuotientFilter {

    private int size;
    private double[] table;
    private int indexTable;
    private final int neg = -1;

    QuotientFilter(int size) {
        this.size = size;
        this.table = new double[size];
        this.indexTable = 0;

        for(int i = 0; i < size; i++){
            this.table[i] = this.neg;
        }
    }

    // Hash function to generate a hash value for the input
    public int hash(String value) {
        return hashStringToBigIntSHA3_256(value).abs().intValue();
    }
    
    public BigInteger hashStringToBigIntSHA3_256(String inputString) {
        try {
            // Get a SHA3-256 MessageDigest instance
            MessageDigest digest = MessageDigest.getInstance("SHA3-256");

            // Hash the input string bytes
            byte[] hashBytes = digest.digest(inputString.getBytes(StandardCharsets.UTF_8));

            // Convert the byte array to a BigInteger
            // The '1' in BigInteger(1, hashBytes) ensures a positive BigInteger value
            return new BigInteger(1, hashBytes);

        } catch (NoSuchAlgorithmException e) {
            // Handle the case where SHA3-256 algorithm is not available
            e.printStackTrace();
            return null; // Or throw a custom exception
        }
    }

    private String bytesToHex(byte[] hash) {
        StringBuilder hexString = new StringBuilder(2 * hash.length);
        for (int i = 0; i < hash.length; i++) {
            String hex = Integer.toHexString(0xff & hash[i]);
            if(hex.length() == 1) {
                hexString.append('0');
            }
            hexString.append(hex);
        }
        return hexString.toString();
    }

    // Insert an element into the Quotient Filter
    public void insert(String element) {
        final int hashValue = this.hash(element);
        // System.out.println("hashValue: " + (hashValue));
        final int quotient = hashValue % this.size;
        final double remainder = Math.floor(hashValue / this.size);

        if (this.table[quotient] == this.neg) {
            this.table[quotient] = remainder;
        } else {
            this.table[quotient] = remainder;
        }
    }

    // Check if an element is in the Quotient Filter
    public boolean contains(String element) {
        final int hashValue = this.hash(element);
        final int quotient = hashValue % this.size;
        final double remainder = Math.floor(hashValue / this.size);

        if ( (quotient > 0 && quotient <= this.size) && this.table[quotient] == this.neg) {
            return false;
        } else {
            return ((quotient > 0 && quotient <= this.size) && this.table[quotient] == remainder);
        }
    }

    public static void teste() {
        // Usage example
        var quotientFilter = new QuotientFilter(100);
        quotientFilter.insert("banana");
        System.out.println(quotientFilter.contains("banana")); // true
        System.out.println(quotientFilter.contains("apple")); // false (or true if there's a false positive)
    }
}
